name: .NET CI

on:
  push:
    branches: [ "main", "master" ] # Declanșează workflow-ul la push pe aceste ramuri
  pull_request:
    branches: [ "main", "master" ] # Declanșează workflow-ul la pull request pe aceste ramuri

env:
  BUILD_OUTPUT_PATH: '${{ github.workspace }}\build_output' # Definim o variabilă de mediu pentru calea de output
  TEST_PROJECT_PATH: 'Rezervari.Tests\Rezervari.Tests.csproj' # Calea către fișierul .csproj al proiectului de test

jobs:
  build-and-test:
    runs-on: windows-latest # Utilizează un agent de rulare Windows, necesar pentru Windows Forms (.NET Framework)

    steps:
    - uses: actions/checkout@v4 # Pasul 1: Verifică codul din repository
      with:
        fetch-depth: 0 # Necesare pentru shallow clones, poate fi util uneori, dar 0 ia tot istoricul

    - name: Setup MSBuild & NuGet # Pasul 2: Configurează uneltele de build pentru .NET Framework
      uses: microsoft/setup-msbuild@v2 # Folosește acțiunea oficială pentru MSBuild
      with:
        vs-version: 'latest' # Va selecta cea mai recentă versiune de Visual Studio (implicit VS 2022)

    - name: Setup NuGet # Pasul 3: Configurează NuGet (managerul de pachete)
      uses: NuGet/setup-nuget@v1 # Folosește acțiunea oficială pentru NuGet

    - name: Restore NuGet packages # Pasul 4: Restaurează dependențele NuGet ale soluției
      run: nuget restore Rezervari.sln # Rulează 'nuget restore' pe fișierul soluției tale

    - name: Build Solution and Publish # Pasul 5: Compilează soluția C# și publică fișierele pentru deployment
      run: |
        msbuild Rezervari.sln /p:Configuration=Release /p:Platform="Any CPU" /p:OutputPath="${{ env.BUILD_OUTPUT_PATH }}"

    - name: Run Tests # Pasul 6: Rulează testele unitare
      # Acum activăm rularea testelor.
      # Pentru proiecte de test .NET Framework (MSTest, NUnit, xUnit), se folosește 'vstest.console.exe'.
      # Calea către vstest.console.exe poate varia ușor. 'dotnet test' poate fi de asemenea o opțiune
      # dacă ai un SDK .NET Core/.NET în același mediu și testele sunt compatibile.
      # Vom folosi 'dotnet test' pentru simplitate și compatibilitate crescută cu mediile CI moderne,
      # presupunând că .NET SDK este disponibil și poate rula teste .NET Framework.
      run: dotnet test ${{ env.TEST_PROJECT_PATH }} --configuration Release --logger "trx;LogFileName=test_results.trx"
      # --configuration Release: Rulează testele pe build-ul Release
      # --logger "trx;LogFileName=test_results.trx": Generează un fișier de rezultate în format TRX

    - name: Upload Test Results # Pasul 7: Încarcă rezultatele testelor ca artefact
      uses: actions/upload-artifact@v4
      if: always() # Încărca oricum, chiar dacă testele eșuează
      with:
        name: TestResults
        path: '**\test_results.trx' # Caută fișierul TRX generat de dotnet test

    - name: Create Deployment Artifact # Pasul 8: Creează un artefact de deployment (fișier .zip)
      uses: actions/upload-artifact@v4
      with:
        name: RezervariApp
        path: ${{ env.BUILD_OUTPUT_PATH }}
