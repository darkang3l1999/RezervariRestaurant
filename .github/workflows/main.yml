# .github/workflows/dotnet-ci.yml
# Acest fișier definește workflow-ul de Continuous Integration (CI) pentru proiectul tău C# Windows Forms.
# Se va rula automat la fiecare push sau pull request pe ramurile 'main' sau 'master'.
name: .NET CI

on:
  push:
    branches: [ "main", "master" ] # Declanșează workflow-ul la push pe aceste ramuri
  pull_request:
    branches: [ "main", "master" ] # Declanșează workflow-ul la pull request pe aceste ramuri

env:
  BUILD_OUTPUT_PATH: '${{ github.workspace }}\build_output' # Definim o variabilă de mediu pentru calea de output

jobs:
  build-and-test:
    runs-on: windows-latest # Utilizează un agent de rulare Windows, necesar pentru Windows Forms (.NET Framework)

    steps:
    - uses: actions/checkout@v4 # Pasul 1: Verifică codul din repository
      with:
        fetch-depth: 0 # Necesare pentru shallow clones, poate fi util uneori, dar 0 ia tot istoricul

    - name: Setup MSBuild & NuGet # Pasul 2: Configurează uneltele de build pentru .NET Framework
      uses: microsoft/setup-msbuild@v2 # Folosește acțiunea oficială pentru MSBuild
      with:
        vs-version: 'latest' # Va selecta cea mai recentă versiune de Visual Studio (implicit VS 2022)

    - name: Setup NuGet # Pasul 3: Configurează NuGet (managerul de pachete)
      uses: NuGet/setup-nuget@v1 # Folosește acțiunea oficială pentru NuGet

    - name: Restore NuGet packages # Pasul 4: Restaurează dependențele NuGet ale soluției
      run: nuget restore Rezervari.sln # Rulează 'nuget restore' pe fișierul soluției tale

    - name: Build Solution and Publish # Pasul 5: Compilează soluția C# și publică fișierele pentru deployment
      # Vom folosi msbuild cu un parametru de output, asigurându-ne că toate DLL-urile sunt colectate.
      # Reține că msbuild /t:Publish este mai mult pentru ClickOnce, dar /p:OutputPath este eficient.
      run: |
        msbuild Rezervari.sln /p:Configuration=Release /p:Platform="Any CPU" /p:OutputPath="${{ env.BUILD_OUTPUT_PATH }}"
        # Această comandă construiește proiectul și plasează toate fișierele compilate
        # (inclusiv DLL-urile dependențelor) în directorul specificat de BUILD_OUTPUT_PATH.

    - name: Run Tests # Pasul 6: Rulează testele unitare (rămâne comentat/sărit deocamdată)
      run: echo "Skipping tests for now. Will enable after unit tests are implemented."


    - name: Create Deployment Artifact # Pasul 7: Creează un artefact de deployment (fișier .zip)
      uses: actions/upload-artifact@v4 # Acțiunea pentru a încărca artefacte
      with:
        name: RezervariApp # Numele artefactului care va fi creat (poate fi descărcat de pe GitHub)
        path: ${{ env.BUILD_OUTPUT_PATH }} # Acum folosim variabila de mediu care conține toate fișierele publicate
        # IMPORTANT: Această cale ar trebui să conțină acum toate fișierele necesare pentru rularea aplicației.
